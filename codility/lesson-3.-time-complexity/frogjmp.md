---
description: '[44% -> 100%]'
---

# FrogJmp

{% hint style="info" %}
작은 개구리가 길 반대편으로 가고 싶어합니다. 개구리는 현재 X 위치에 있으며 Y보다 크거나 같은 위치로 이동하려고 합니다. 작은 개구리는 항상 고정된 거리 D만큼 점프합니다.

작은 개구리가 목표에 도달하기 위해 수행해야 하는 최소 점프 횟수를 세어보세요.

함수를 작성하세요:

> def solution(X, Y, D)

세 개의 정수 X, Y, D가 주어지면 X 위치에서 Y보다 크거나 같은 위치로 점프하는 최소 횟수를 반환합니다.

예를 들어, 다음과 같습니다.

X = 10 Y = 85 D = 30

개구리의 위치는 다음과 같으므로 함수는 3을 반환해야 합니다.

> * 첫 번째 점프 후 위치 10 + 30 = 40
> * 두 번째 점프 후 위치 10 + 30 + 30 = 70
> * 세 번째 점프 후 위치 10 + 30 + 30 + 30 = 100

다음 가정에 대한 효율적인 알고리즘을 작성하십시오 .

> * X, Y 및 D는 \[ 1 .. 1,000,000,000 ] 범위 내의 정수입니다 .
> * X ≤ Y.



Codility Limited의 저작권 2009-2023. 판권 소유. 무단복제, 출판, 공개를 금지합니다.
{% endhint %}



<mark style="background-color:blue;">**접근 방법**</mark>

1. X는 Y보다 크거나 같은 위치라는 점에서 솔루션이 생각났습니다.
2.  $$Y <= X + D*count$$

    $$count >= (Y-X)/D$$
3. 그래서 (Y-X) % D가 나누어 떨어지면 같은 위치이기 때문에, **count는 (Y-X)//D**가 되는 것이고, 나누어 떨어진다면 더 높은 위치이기 때문에, **count는 (Y-X)//D 이 값에 1을 더해**주었습니다.



<mark style="background-color:green;">**내가 작성한 코드**</mark>

```python
def solution(X, Y, D):
    return (Y-X) // D + 1
```

<mark style="background-color:red;">점수: 44%</mark>

* 처음에는 앞에 코드처럼 짜면 되겠지 생각했습니다. 하지만, 위치는 크거나 같다는 지문이 있었다는 것을 되짚어봤을 때, 같을 때는 1을 더하면 안되기 때문에 다음과 같이 수정했습니다.
* 그래서 (Y-X) % D가 나누어 떨어지면 같은 위치이기 때문에, **count는 (Y-X)//D**가 되는 것이고, 나누어 떨어진다면 더 높은 위치이기 때문에, **count는 (Y-X)//D 이 값에 1을 더해**주었습니다.



<mark style="background-color:orange;">**수정한 코드**</mark>

```python
def solution(X, Y, D):
    if (Y-X) % D == 0:
        count = (Y-X) // D
    else:
        count = (Y-X) // D + 1

    return count
```
